---
title: "Gazebo Physics"
description: "Learn about physics simulation in Gazebo for humanoid robotics applications"
tags: [gazebo, physics, simulation, robotics, dynamics]
sidebar_label: "Gazebo Physics"
sidebar_position: 3
keywords: [gazebo, physics, simulation, robotics]
toc_min_heading_level: 2
toc_max_heading_level: 4
---

# Gazebo Physics

import TOCInline from '@theme/TOCInline';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<TOCInline toc={toc} />

## Overview

Gazebo is the premier simulation environment for robotics, providing realistic physics simulation that is essential for developing and testing humanoid robots. In this chapter, we'll explore the physics engine that powers Gazebo, how to configure realistic physical properties for humanoid robots, and how to create accurate simulation environments that enable effective sim-to-real transfer.

Understanding Gazebo's physics capabilities is crucial for humanoid robotics because these robots operate in complex physical environments where balance, locomotion, and interaction with objects require precise physics modeling. We'll cover everything from basic rigid body dynamics to advanced contact simulation that's essential for bipedal locomotion.

### Learning Objectives

- Understand Gazebo's physics engine architecture and capabilities
- Configure realistic physical properties for humanoid robot models
- Implement accurate contact simulation for robot-environment interaction
- Create complex simulation scenarios with multiple interacting objects
- Optimize physics parameters for performance and accuracy
- Validate physics simulation against real-world robot behavior

### Prerequisites

- Understanding of basic physics concepts (forces, torques, dynamics)
- Knowledge of URDF robot modeling from Module 1
- Basic understanding of ROS 2 simulation concepts

## Deep Explanation

### Gazebo Physics Engine Architecture

Gazebo uses Open Source Physics (OSP) engines to simulate realistic physics interactions. The primary engines include:

#### ODE (Open Dynamics Engine)
- Fast and stable for most robotic applications
- Good for rigid body dynamics and basic contact simulation
- Suitable for humanoid robots with multiple degrees of freedom

#### Bullet Physics
- More advanced collision detection and response
- Better handling of complex contact scenarios
- Good for manipulation tasks and detailed contact simulation

#### DART (Dynamic Animation and Robotics Toolkit)
- Advanced contact simulation and stability
- Better for complex multi-body systems
- Excellent for humanoid locomotion simulation

### Physics Properties Configuration

For humanoid robots, accurate physics configuration is critical and includes:

#### Mass Properties
- **Mass**: Must be accurately specified for each link
- **Center of Mass**: Critical for balance and locomotion
- **Inertia Tensor**: Affects how the robot responds to forces and torques

#### Inertial Properties
The inertia tensor describes how mass is distributed in a rigid body. For humanoid robots, this affects:
- Balance control performance
- Walking gait stability
- Response to external forces

#### Collision Properties
- **Collision Shapes**: Simplified geometry for efficient collision detection
- **Surface Properties**: Friction, restitution, and contact parameters
- **Contact Materials**: How different materials interact

### Contact Simulation for Humanoid Robots

Humanoid robots require sophisticated contact simulation because:

#### Foot-Ground Contact
- Critical for stable walking and balance
- Requires accurate friction modeling
- Must handle dynamic loading during walking phases

#### Multi-Contact Scenarios
- Walking involves multiple contact points
- Balance control depends on contact state estimation
- Requires stable contact resolution

#### Manipulation Contact
- Grasping and manipulation require precise contact modeling
- Force control depends on accurate contact simulation
- Object interaction needs realistic physics

### Physics Performance Considerations

Gazebo physics simulation involves trade-offs between:

#### Accuracy vs. Performance
- Smaller time steps increase accuracy but decrease performance
- Complex collision geometries improve realism but reduce speed
- More contact points provide better stability but increase computation

#### Realism vs. Stability
- Realistic parameters can lead to simulation instability
- Simplified models may be more stable but less realistic
- Parameter tuning is often required for optimal results

### World Configuration

Gazebo worlds are configured using SDF (Simulation Description Format) files that define:

#### Global Physics Parameters
- Gravity settings
- Real-time update rates
- Solver parameters
- Default material properties

#### Environmental Objects
- Ground planes with appropriate friction
- Obstacles and structures
- Interactive objects for manipulation tasks
- Sensors and actuators in the environment

## Practical Examples

### Example 1: Gazebo World Configuration for Humanoid Robotics

<Tabs>
<TabItem value="world_file" label="SDF World File" default>

```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="humanoid_test_world">
    <!-- Physics configuration optimized for humanoid robots -->
    <physics name="humanoid_physics" type="ode">
      <max_step_size>0.001</max_step_size>  <!-- 1ms time step for accuracy -->
      <real_time_factor>1.0</real_time_factor>
      <real_time_update_rate>1000.0</real_time_update_rate>
      <gravity>0 0 -9.8</gravity>

      <!-- ODE solver parameters for stable humanoid simulation -->
      <ode>
        <solver>
          <type>quick</type>  <!-- Fast iterative solver -->
          <iters>1000</iters>  <!-- More iterations for stability -->
          <sor>1.3</sor>      <!-- Successive over-relaxation parameter -->
        </solver>
        <constraints>
          <cfm>0.000001</cfm>  <!-- Constraint Force Mixing -->
          <erp>0.2</erp>      <!-- Error Reduction Parameter -->
          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
          <contact_surface_layer>0.001</contact_surface_layer>
        </constraints>
      </ode>
    </physics>

    <!-- Lighting configuration -->
    <light name="sun" type="directional">
      <cast_shadows>true</cast_shadows>
      <pose>0 0 10 0 0 0</pose>
      <diffuse>0.8 0.8 0.8 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <attenuation>
        <range>1000</range>
        <constant>0.9</constant>
        <linear>0.01</linear>
        <quadratic>0.001</quadratic>
      </attenuation>
      <direction>-0.4 0.2 -1</direction>
    </light>

    <!-- Ground plane with humanoid-appropriate friction -->
    <model name="ground_plane">
      <static>true</static>
      <link name="link">
        <collision name="collision">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <surface>
            <friction>
              <ode>
                <mu>0.8</mu>    <!-- High friction for stable walking -->
                <mu2>0.8</mu2>  <!-- Secondary friction for multi-axis -->
              </ode>
              <torsional>
                <coefficient>0.8</coefficient>
              </torsional>
            </friction>
            <bounce>
              <restitution_coefficient>0.1</restitution_coefficient>
              <threshold>100000</threshold>
            </bounce>
            <contact>
              <ode>
                <max_vel>100.0</max_vel>
                <min_depth>0.001</min_depth>
              </ode>
            </contact>
          </surface>
        </collision>
        <visual name="visual">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <material>
            <ambient>0.7 0.7 0.7 1</ambient>
            <diffuse>0.7 0.7 0.7 1</diffuse>
            <specular>0.0 0.0 0.0 1</specular>
          </material>
        </visual>
      </link>
    </model>

    <!-- Example humanoid robot spawn point -->
    <include>
      <uri>model://simple_humanoid</uri>
      <pose>0 0 1 0 0 0</pose>
    </include>

    <!-- Testing obstacles -->
    <model name="ramp">
      <pose>-2 0 0.1 0 0.2 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>2.0 1.0 0.2</size>
            </box>
          </geometry>
          <surface>
            <friction>
              <ode>
                <mu>0.8</mu>
                <mu2>0.8</mu2>
              </ode>
            </friction>
          </surface>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>2.0 1.0 0.2</size>
            </box>
          </geometry>
          <material>
            <ambient>0.6 0.4 0.2 1</ambient>
            <diffuse>0.6 0.4 0.2 1</diffuse>
          </material>
        </visual>
        <inertial>
          <mass>10.0</mass>
          <inertia>
            <ixx>0.833</ixx>
            <ixy>0</ixy>
            <ixz>0</ixz>
            <iyy>3.333</iyy>
            <iyz>0</iyz>
            <izz>4.167</izz>
          </inertia>
        </inertial>
      </link>
    </model>

    <!-- Balance testing platform -->
    <model name="narrow_platform">
      <pose>2 0 0.05 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.2 1.0 0.1</size>
            </box>
          </geometry>
          <surface>
            <friction>
              <ode>
                <mu>0.8</mu>
                <mu2>0.8</mu2>
              </ode>
            </friction>
          </surface>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.2 1.0 0.1</size>
            </box>
          </geometry>
          <material>
            <ambient>0.8 0.6 0.2 1</ambient>
            <diffuse>0.8 0.6 0.2 1</diffuse>
          </material>
        </visual>
        <inertial>
          <mass>5.0</mass>
          <inertia>
            <ixx>0.417</ixx>
            <ixy>0</ixy>
            <ixz>0</ixz>
            <iyy>0.085</iyy>
            <iyz>0</iyz>
            <izz>0.498</izz>
          </inertia>
        </inertial>
      </link>
    </model>
  </world>
</sdf>
```

</TabItem>
<TabItem value="robot_config" label="Robot Physics Configuration">

```xml
<?xml version="1.0"?>
<robot name="humanoid_with_physics">
  <!-- Base link with realistic physics properties -->
  <link name="base_link">
    <inertial>
      <mass value="10.0"/>  <!-- Heavier base for stability -->
      <origin xyz="0 0 0.1" rpy="0 0 0"/>  <!-- Offset COM for realistic balance -->
      <inertia
        ixx="0.5" ixy="0.0" ixz="0.0"
        iyy="0.5" iyz="0.0"
        izz="0.3"/>
    </inertial>

    <visual>
      <geometry>
        <box size="0.3 0.2 0.4"/>
      </geometry>
      <material name="blue">
        <color rgba="0 0 1 1"/>
      </material>
    </visual>

    <collision>
      <geometry>
        <box size="0.3 0.2 0.4"/>
      </geometry>
    </collision>
  </link>

  <!-- Head link -->
  <link name="head">
    <inertial>
      <mass value="2.0"/>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <inertia
        ixx="0.02" ixy="0.0" ixz="0.0"
        iyy="0.02" iyz="0.0"
        izz="0.02"/>
    </inertial>

    <visual>
      <geometry>
        <sphere radius="0.1"/>
      </geometry>
      <material name="white">
        <color rgba="1 1 1 1"/>
      </material>
    </visual>

    <collision>
      <geometry>
        <sphere radius="0.1"/>
      </geometry>
    </collision>
  </link>

  <!-- Joint with physics constraints -->
  <joint name="neck_joint" type="revolute">
    <parent link="base_link"/>
    <child link="head"/>
    <origin xyz="0 0 0.3" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>  <!-- Y-axis for head nodding -->
    <limit lower="-0.5" upper="0.5" effort="10.0" velocity="2.0"/>
    <dynamics damping="0.1" friction="0.01"/>  <!-- Realistic joint dynamics -->
  </joint>

  <!-- Left leg with realistic physics for walking -->
  <link name="left_thigh">
    <inertial>
      <mass value="3.0"/>
      <origin xyz="0 0 -0.15" rpy="0 0 0"/>  <!-- COM offset down toward knee -->
      <inertia
        ixx="0.08" ixy="0.0" ixz="0.01"
        iyy="0.08" iyz="0.0"
        izz="0.01"/>
    </inertial>

    <visual>
      <geometry>
        <cylinder length="0.3" radius="0.06"/>
      </geometry>
      <origin xyz="0 0 -0.15" rpy="1.5708 0 0"/>  <!-- Rotate to vertical -->
      <material name="gray">
        <color rgba="0.5 0.5 0.5 1"/>
      </material>
    </visual>

    <collision>
      <geometry>
        <cylinder length="0.3" radius="0.06"/>
      </geometry>
      <origin xyz="0 0 -0.15" rpy="1.5708 0 0"/>
    </collision>
  </link>

  <!-- Hip joint with walking-appropriate limits -->
  <joint name="left_hip_joint" type="revolute">
    <parent link="base_link"/>
    <child link="left_thigh"/>
    <origin xyz="-0.05 -0.1 -0.2" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>  <!-- Flexion/extension -->
    <limit lower="-1.0" upper="0.5" effort="50.0" velocity="5.0"/>
    <dynamics damping="1.0" friction="0.1"/>  <!-- Higher damping for stability -->
  </joint>

  <!-- Left shin with realistic properties -->
  <link name="left_shin">
    <inertial>
      <mass value="2.0"/>
      <origin xyz="0 0 -0.12" rpy="0 0 0"/>
      <inertia
        ixx="0.04" ixy="0.0" ixz="0.005"
        iyy="0.04" iyz="0.0"
        izz="0.008"/>
    </inertial>

    <visual>
      <geometry>
        <cylinder length="0.24" radius="0.05"/>
      </geometry>
      <origin xyz="0 0 -0.12" rpy="1.5708 0 0"/>
      <material name="gray">
        <color rgba="0.5 0.5 0.5 1"/>
      </material>
    </visual>

    <collision>
      <geometry>
        <cylinder length="0.24" radius="0.05"/>
      </geometry>
      <origin xyz="0 0 -0.12" rpy="1.5708 0 0"/>
    </collision>
  </link>

  <!-- Knee joint -->
  <joint name="left_knee_joint" type="revolute">
    <parent link="left_thigh"/>
    <child link="left_shin"/>
    <origin xyz="0 0 -0.3" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>
    <limit lower="0.0" upper="2.0" effort="40.0" velocity="4.0"/>
    <dynamics damping="0.8" friction="0.05"/>
  </joint>

  <!-- Left foot with contact properties -->
  <link name="left_foot">
    <inertial>
      <mass value="1.0"/>
      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>
      <inertia
        ixx="0.01" ixy="0.0" ixz="0.001"
        iyy="0.02" iyz="0.0"
        izz="0.015"/>
    </inertial>

    <visual>
      <geometry>
        <box size="0.18 0.1 0.06"/>
      </geometry>
      <material name="dark_gray">
        <color rgba="0.3 0.3 0.3 1"/>
      </material>
    </visual>

    <collision>
      <geometry>
        <box size="0.18 0.1 0.06"/>
      </geometry>
    </collision>
  </link>

  <!-- Ankle joint -->
  <joint name="left_ankle_joint" type="revolute">
    <parent link="left_shin"/>
    <child link="left_foot"/>
    <origin xyz="0 0 -0.24" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>
    <limit lower="-0.5" upper="0.5" effort="20.0" velocity="3.0"/>
    <dynamics damping="0.5" friction="0.02"/>
  </joint>
</robot>
```

</TabItem>
</Tabs>

### Example 2: Physics Parameter Tuning and Validation

<Tabs>
<TabItem value="physics_validator" label="Physics Validation Node">

```python
#!/usr/bin/env python3
# Example: Physics validation node for Gazebo simulation

import rclpy
from rclpy.node import Node
from gazebo_msgs.srv import GetModelState, SetModelState
from gazebo_msgs.msg import ModelState
from geometry_msgs.msg import Point, Pose, Twist
from sensor_msgs.msg import JointState
from std_msgs.msg import Float64MultiArray
import numpy as np
import math


class PhysicsValidator(Node):
    """
    A node that validates Gazebo physics simulation by comparing
    expected vs actual robot behavior.
    """

    def __init__(self):
        super().__init__('physics_validator')

        # Gazebo services for model state
        self.get_state_client = self.create_client(
            GetModelState,
            '/gazebo/get_model_state'
        )

        self.set_state_client = self.create_client(
            SetModelState,
            '/gazebo/set_model_state'
        )

        # Publishers for validation results
        self.validation_pub = self.create_publisher(
            Float64MultiArray,
            '/physics_validation/results',
            10
        )

        # Joint state subscription for robot feedback
        self.joint_state_sub = self.create_subscription(
            JointState,
            '/joint_states',
            self.joint_state_callback,
            10
        )

        # Timer for periodic validation
        self.validation_timer = self.create_timer(0.1, self.validation_callback)

        # State tracking
        self.joint_states = None
        self.model_name = 'simple_humanoid'  # Default model name
        self.relative_entity_name = 'world'  # Default reference frame

        # Physics validation parameters
        self.validation_params = {
            'gravity_tolerance': 0.1,      # Tolerance for gravity validation
            'balance_threshold': 0.3,      # Tilt threshold for balance
            'contact_sensitivity': 0.01,   # Sensitivity for contact detection
            'dynamics_accuracy': 0.05      # Accuracy threshold for dynamics
        }

        self.get_logger().info('Physics Validator initialized')

    def joint_state_callback(self, msg):
        """Handle joint state updates."""
        self.joint_states = msg

    def validation_callback(self):
        """Perform periodic physics validation."""
        # Validate model state
        state_result = self.get_model_state()

        if state_result is not None:
            # Extract position and orientation
            position = state_result.pose.position
            orientation = state_result.pose.orientation

            # Calculate tilt angle (simplified)
            tilt_angle = self.calculate_tilt_angle(orientation)

            # Validate balance
            balance_valid = abs(tilt_angle) < self.validation_params['balance_threshold']

            # Validate physics properties
            physics_metrics = self.validate_physics_properties(
                position, orientation, state_result.twist
            )

            # Publish validation results
            validation_msg = Float64MultiArray()
            validation_msg.data = [
                float(balance_valid),  # Balance status
                tilt_angle,            # Current tilt
                physics_metrics['energy'],  # Energy conservation
                physics_metrics['stability'],  # Stability metric
                self.validation_params['balance_threshold']  # Threshold
            ]

            self.validation_pub.publish(validation_msg)

            # Log validation results
            if not balance_valid:
                self.get_logger().warn(f'Balance validation failed: tilt={tilt_angle:.3f}')

    def get_model_state(self):
        """Get current model state from Gazebo."""
        while not self.get_state_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Gazebo service not available, waiting...')

        request = GetModelState.Request()
        request.model_name = self.model_name
        request.relative_entity_name = self.relative_entity_name

        future = self.get_state_client.call_async(request)

        # Wait for response (in a real implementation, use proper async handling)
        import time
        start_time = time.time()
        while not future.done() and time.time() - start_time < 1.0:
            time.sleep(0.01)

        if future.done():
            try:
                response = future.result()
                if response.success:
                    return response
                else:
                    self.get_logger().error(f'GetModelState failed: {response.status_message}')
                    return None
            except Exception as e:
                self.get_logger().error(f'Error getting model state: {e}')
                return None
        else:
            self.get_logger().error('GetModelState service call timed out')
            return None

    def calculate_tilt_angle(self, orientation):
        """Calculate tilt angle from orientation quaternion."""
        # Simplified calculation - extract pitch from quaternion
        w, x, y, z = orientation.w, orientation.x, orientation.y, orientation.z

        # Calculate pitch (rotation around Y axis)
        sinr_cosp = 2 * (w * y - z * x)
        cosr_cosp = 1 - 2 * (y * y + x * x)
        pitch = math.atan2(sinr_cosp, cosr_cosp)

        return pitch

    def validate_physics_properties(self, position, orientation, twist):
        """Validate physics properties like energy conservation and stability."""
        # Calculate kinetic energy from twist
        linear_vel = twist.linear
        angular_vel = twist.angular

        # Simplified kinetic energy calculation (assuming mass of 10kg)
        mass = 10.0
        linear_energy = 0.5 * mass * (
            linear_vel.x**2 + linear_vel.y**2 + linear_vel.z**2
        )

        # Simplified angular energy (assuming moment of inertia)
        angular_energy = 0.5 * 1.0 * (
            angular_vel.x**2 + angular_vel.y**2 + angular_vel.z**2
        )

        total_energy = linear_energy + angular_energy

        # Calculate stability based on position and velocity
        position_magnitude = math.sqrt(position.x**2 + position.y**2 + position.z**2)
        velocity_magnitude = math.sqrt(
            twist.linear.x**2 + twist.linear.y**2 + twist.linear.z**2
        )

        # Stability metric (lower is more stable)
        stability = position_magnitude * velocity_magnitude

        return {
            'energy': total_energy,
            'stability': stability,
            'position_magnitude': position_magnitude,
            'velocity_magnitude': velocity_magnitude
        }

    def validate_gravity_simulation(self):
        """Validate that gravity is properly simulated."""
        state_result = self.get_model_state()

        if state_result is not None:
            # Check if the model is experiencing gravity by looking at Z acceleration
            # This is a simplified check - in reality, you'd need to filter for other forces
            twist = state_result.twist

            # If Z velocity is changing appropriately, gravity is likely working
            # This is a placeholder implementation
            expected_gravity = -9.81  # m/s^2
            actual_z_accel = twist.linear.z  # This won't be pure acceleration

            # For a more accurate check, you'd need to track velocity over time
            # and calculate acceleration, or use Gazebo's physics properties directly

            return abs(actual_z_accel - expected_gravity) < self.validation_params['gravity_tolerance']

        return False

    def tune_physics_parameters(self, model_name, link_name, mass, inertia):
        """Dynamically tune physics parameters for better simulation."""
        # This would involve calling Gazebo services to modify model properties
        # For now, this is a placeholder that would implement parameter tuning logic

        self.get_logger().info(f'Tuning physics for {model_name}:{link_name}')

        # In a real implementation, this would:
        # 1. Analyze current simulation performance
        # 2. Adjust mass, inertia, friction, etc. based on validation results
        # 3. Validate the changes
        # 4. Iterate until optimal parameters are found


def main(args=None):
    """Main function to run the physics validator."""
    rclpy.init(args=args)

    validator = PhysicsValidator()

    try:
        rclpy.spin(validator)
    except KeyboardInterrupt:
        print("Physics validator interrupted by user")
    finally:
        validator.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

</TabItem>
<TabItem value="contact_analyzer" label="Contact Analysis">

```python
#!/usr/bin/env python3
# Example: Contact analysis for humanoid robot physics simulation

import rclpy
from rclpy.node import Node
from gazebo_msgs.srv import GetContactProperties
from gazebo_msgs.msg import ContactsState
from geometry_msgs.msg import Wrench, Vector3
from std_msgs.msg import Float64MultiArray
import numpy as np


class ContactAnalyzer(Node):
    """
    Analyzes contact forces and torques for humanoid robot simulation.
    Critical for understanding foot-ground interaction and balance.
    """

    def __init__(self):
        super().__init__('contact_analyzer')

        # Service for getting contact properties
        self.contact_service = self.create_client(
            GetContactProperties,
            '/gazebo/get_contact_properties'
        )

        # Subscriber for contact state (if available)
        self.contact_sub = self.create_subscription(
            ContactsState,
            '/gazebo/contact_states',
            self.contact_callback,
            10
        )

        # Publishers for analysis results
        self.zmp_pub = self.create_publisher(
            Float64MultiArray,
            '/contact_analysis/zmp',
            10
        )

        self.pressure_pub = self.create_publisher(
            Float64MultiArray,
            '/contact_analysis/pressure',
            10
        )

        self.stability_pub = self.create_publisher(
            Float64MultiArray,
            '/contact_analysis/stability',
            10
        )

        # Timer for periodic analysis
        self.analysis_timer = self.create_timer(0.02, self.analysis_callback)  # 50Hz

        # Contact tracking
        self.contacts = {}
        self.foot_links = ['left_foot', 'right_foot']  # Common foot link names

        # ZMP (Zero Moment Point) calculation parameters
        self.zmp_window_size = 10  # Number of samples for smoothing
        self.zmp_history = {'x': [], 'y': []}

        self.get_logger().info('Contact Analyzer initialized')

    def contact_callback(self, msg):
        """Handle contact state messages."""
        for contact in msg.states:
            # Process each contact
            for i, collision1 in enumerate(contact.collision1_name):
                collision2 = contact.collision2_name[i] if i < len(contact.collision2_name) else ""

                # Identify if this is a foot-ground contact
                foot_collision = None
                ground_collision = None

                if any(foot_link in collision1 for foot_link in self.foot_links):
                    foot_collision = collision1
                    ground_collision = collision2
                elif any(foot_link in collision2 for foot_link in self.foot_links):
                    foot_collision = collision2
                    ground_collision = collision1

                if foot_collision and ground_collision:
                    # Process foot-ground contact
                    total_force = Vector3()
                    total_torque = Vector3()

                    # Sum up all contact forces and torques
                    for wrench in contact.wrenches:
                        total_force.x += wrench.force.x
                        total_force.y += wrench.force.y
                        total_force.z += wrench.force.z
                        total_torque.x += wrench.torque.x
                        total_torque.y += wrench.torque.y
                        total_torque.z += wrench.torque.z

                    # Store contact information
                    self.contacts[foot_collision] = {
                        'force': total_force,
                        'torque': total_torque,
                        'position': contact.contact_positions[0] if contact.contact_positions else None,
                        'normal': contact.contact_normals[0] if contact.contact_normals else None
                    }

    def analysis_callback(self):
        """Perform periodic contact analysis."""
        if not self.contacts:
            return

        # Analyze each foot contact
        for foot_link, contact_data in self.contacts.items():
            if contact_data['position'] is not None:
                # Calculate ZMP (Zero Moment Point)
                zmp = self.calculate_zmp(
                    contact_data['force'],
                    contact_data['torque'],
                    contact_data['position']
                )

                if zmp is not None:
                    # Update ZMP history for smoothing
                    self.zmp_history['x'].append(zmp[0])
                    self.zmp_history['y'].append(zmp[1])

                    # Keep only recent samples
                    if len(self.zmp_history['x']) > self.zmp_window_size:
                        self.zmp_history['x'].pop(0)
                        self.zmp_history['y'].pop(0)

                    # Calculate smoothed ZMP
                    smoothed_zmp_x = np.mean(self.zmp_history['x']) if self.zmp_history['x'] else 0
                    smoothed_zmp_y = np.mean(self.zmp_history['y']) if self.zmp_history['y'] else 0

                    # Publish ZMP
                    zmp_msg = Float64MultiArray()
                    zmp_msg.data = [smoothed_zmp_x, smoothed_zmp_y, zmp[0], zmp[1]]
                    self.zmp_pub.publish(zmp_msg)

                    # Calculate pressure distribution
                    pressure = self.calculate_pressure(contact_data['force'])
                    pressure_msg = Float64MultiArray()
                    pressure_msg.data = [pressure, contact_data['force'].z]
                    self.pressure_pub.publish(pressure_msg)

                    # Calculate stability metric
                    stability = self.calculate_stability_metric(zmp, foot_link)
                    stability_msg = Float64MultiArray()
                    stability_msg.data = [stability, 1.0 if stability < 0.1 else 0.0]  # Stability flag
                    self.stability_pub.publish(stability_msg)

    def calculate_zmp(self, force, torque, position):
        """Calculate Zero Moment Point (ZMP) from contact forces."""
        # ZMP calculation: (x, y) = (x_com - (torque_y/mg), y_com - (torque_x/mg))
        # Simplified for foot contact on ground (z=0 plane)

        if force.z == 0:  # Avoid division by zero
            return None

        # Calculate ZMP relative to contact point
        zmp_x = position.x - (torque.y / force.z)
        zmp_y = position.y + (torque.x / force.z)

        return (zmp_x, zmp_y)

    def calculate_pressure(self, force):
        """Calculate pressure from contact force."""
        # Simplified pressure calculation
        # In reality, you'd need contact area to calculate true pressure
        force_magnitude = np.sqrt(force.x**2 + force.y**2 + force.z**2)

        # Assume a typical foot contact area for pressure estimation
        typical_foot_area = 0.01  # 100 cm^2 in m^2
        pressure = force_magnitude / typical_foot_area if typical_foot_area > 0 else 0

        return pressure

    def calculate_stability_metric(self, zmp, foot_link):
        """Calculate stability metric based on ZMP position."""
        if zmp is None:
            return float('inf')  # Unstable if no ZMP

        # Get approximate foot boundary (simplified)
        # In a real system, you'd get this from the robot model
        if 'left' in foot_link.lower():
            # Left foot boundary (approximate)
            foot_boundary = {
                'min_x': -0.09, 'max_x': 0.09,  # 18cm length
                'min_y': -0.05, 'max_y': 0.05   # 10cm width
            }
        else:
            # Right foot boundary (approximate)
            foot_boundary = {
                'min_x': -0.09, 'max_x': 0.09,
                'min_y': -0.05, 'max_y': 0.05
            }

        # Calculate distance from ZMP to foot boundary
        x_dist = max(0, abs(zmp[0]) - (foot_boundary['max_x'] - foot_boundary['min_x'])/2)
        y_dist = max(0, abs(zmp[1]) - (foot_boundary['max_y'] - foot_boundary['min_y'])/2)

        # Stability is proportional to how far ZMP is from boundary
        stability = np.sqrt(x_dist**2 + y_dist**2)

        return stability

    def get_foot_contact_info(self, foot_link_name):
        """Get contact information for a specific foot."""
        return self.contacts.get(foot_link_name, None)


def main(args=None):
    """Main function to run the contact analyzer."""
    rclpy.init(args=args)

    analyzer = ContactAnalyzer()

    try:
        rclpy.spin(analyzer)
    except KeyboardInterrupt:
        print("Contact analyzer interrupted by user")
    finally:
        analyzer.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

</TabItem>
</Tabs>

## Exercises and Checkpoints

### Exercise 1: Physics Parameter Optimization

**Scenario:** You have a humanoid robot model that exhibits unstable walking behavior in Gazebo simulation. The robot falls over easily and doesn't respond to balance control commands as expected.

**Task:** Identify and optimize the physics parameters that could be causing the instability, including:
- Mass and inertia properties
- Joint damping and friction
- Contact surface properties
- Global physics solver parameters

**Success Criteria:**
- [ ] Improved stability in simulation
- [ ] Realistic response to forces and torques
- [ ] Proper balance control integration
- [ ] Validated against physical robot behavior

### Exercise 2: Contact Simulation Setup

**Objective:** Configure realistic contact simulation for a humanoid robot's feet that enables stable walking.

**Task:** Set up contact properties for humanoid robot feet including:
- Appropriate friction coefficients for walking
- Realistic contact surface parameters
- Proper collision geometry
- Force and torque sensor simulation

**Success Criteria:**
- [ ] Stable foot-ground contact during walking
- [ ] Realistic force distribution
- [ ] Proper ZMP (Zero Moment Point) calculation
- [ ] Accurate pressure distribution modeling

### Self-Assessment Questions

1. **Question:** What are the key physics parameters that affect humanoid robot stability in Gazebo?
   **Answer:** Key parameters include: mass distribution and center of mass, inertia tensors, joint damping and friction, contact friction coefficients, and global physics solver settings.

2. **Question:** Why is contact simulation particularly important for humanoid robots?
   **Answer:** Contact simulation is critical for humanoid robots because: walking requires precise foot-ground interaction, balance control depends on accurate contact force feedback, and manipulation tasks require realistic object interaction.

3. **Question:** What is the Zero Moment Point (ZMP) and why is it important in humanoid robotics?
   **Answer:** ZMP is a point where the net moment of the ground reaction forces is zero. It's important for humanoid robotics because it's used in balance control algorithms to determine stable walking patterns and maintain balance.

## Summary and Key Takeaways

### Key Concepts Recap

- **Physics Engine**: Gazebo uses OSP engines (ODE, Bullet, DART) for realistic simulation
- **Mass Properties**: Accurate mass, center of mass, and inertia tensors are critical
- **Contact Simulation**: Realistic contact properties enable stable robot interaction
- **Solver Parameters**: Time steps and solver settings affect stability and performance
- **Validation**: Physics validation ensures simulation matches real-world behavior

### Practical Applications

- **Walking Simulation**: Accurate physics enables realistic bipedal locomotion
- **Balance Control**: Proper contact simulation supports balance algorithms
- **Manipulation**: Realistic contact forces enable dexterous manipulation
- **Safety Testing**: Physics simulation allows safe testing of robot behaviors

### Next Steps

- **Module Progression:** Next chapter covers [Unity Visualization](./unity-visualization.mdx) for advanced graphics
- **Further Reading:** Explore advanced Gazebo plugins and custom physics
- **Practice Opportunities:** Implement physics validation for your robot model

### Common Mistakes and Troubleshooting

- **Mistake 1:** Incorrect mass/inertia properties → **Solution:** Validate with real robot or CAD model
- **Mistake 2:** Poor contact parameters → **Solution:** Tune friction and surface properties for realistic interaction
- **Mistake 3:** Unstable physics solver → **Solution:** Adjust time steps and solver parameters for stability

### References and Resources

- [Gazebo Physics Documentation](http://gazebosim.org/tutorials?tut=physics)
- [SDF World Format](http://sdformat.org/spec)
- [ROS 2 Gazebo Integration](https://gazebosim.org/docs/harmonic/ros_integration)
- [Physics-Based Robot Simulation](https://arxiv.org/abs/1907.03306)