# Gazebo Simulation Integration with ROS 2

## Overview

This guide provides a comprehensive approach to integrating Gazebo simulation with ROS 2 for humanoid robotics applications. The integration enables realistic physics simulation, sensor modeling, and control system development in a safe, repeatable environment.

## Architecture Overview

The Gazebo-ROS 2 integration follows a plugin-based architecture where Gazebo communicates with ROS 2 through specialized plugins that bridge the simulation and control systems.

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Gazebo       │    │   Gazebo-ROS   │    │   ROS 2         │
│   Simulation   │◄──►│   Bridge       │◄──►│   Control &     │
│                │    │   Plugins      │    │   Perception    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## Required Components

### 1. Gazebo Installation
Ensure Gazebo Garden (or compatible version) is installed with ROS 2 support:

```bash
# For Ubuntu 22.04 with ROS 2 Humble
sudo apt update
sudo apt install ros-humble-gazebo-ros-pkgs ros-humble-gazebo-ros2-control
```

### 2. Essential ROS 2 Packages
- `gazebo_ros_pkgs`: Core Gazebo-ROS integration
- `gazebo_ros2_control`: ROS 2 control system integration
- `ros2_control`: Generic control system framework
- `ros2_controllers`: Standard controller implementations

## Robot Model Configuration

### URDF/XACRO Setup

Create a URDF or XACRO model with proper Gazebo integration tags:

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid_robot">

  <!-- Include Gazebo-specific configurations -->
  <gazebo>
    <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">
      <parameters>$(find my_robot_description)/config/controllers.yaml</parameters>
    </plugin>
  </gazebo>

  <!-- Robot links and joints -->
  <link name="base_link">
    <inertial>
      <mass value="10.0"/>
      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/>
    </inertial>
    <visual>
      <geometry>
        <box size="0.2 0.2 0.2"/>
      </geometry>
    </visual>
    <collision>
      <geometry>
        <box size="0.2 0.2 0.2"/>
      </geometry>
    </collision>
  </link>

  <!-- Example joint with transmission -->
  <joint name="hip_joint" type="revolute">
    <parent link="base_link"/>
    <child link="upper_leg_link"/>
    <axis xyz="0 0 1"/>
    <limit lower="-1.57" upper="1.57" effort="100" velocity="3.0"/>
    <origin xyz="0 0 -0.5"/>
  </joint>

  <link name="upper_leg_link">
    <inertial>
      <mass value="2.0"/>
      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>
    </inertial>
  </link>

  <!-- Transmission for ROS 2 Control -->
  <transmission name="trans_hip_joint">
    <type>transmission_interface/SimpleTransmission</type>
    <joint name="hip_joint">
      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
    </joint>
    <actuator name="hip_motor">
      <mechanicalReduction>1</mechanicalReduction>
    </actuator>
  </transmission>

</robot>
```

### Controller Configuration

Create a controller configuration file (`config/controllers.yaml`):

```yaml
controller_manager:
  ros__parameters:
    update_rate: 100  # Hz

    joint_state_broadcaster:
      type: joint_state_broadcaster/JointStateBroadcaster

    # Position controllers for each joint group
    joint_group_position_controller:
      type: position_controllers/JointGroupPositionController

    # Individual joint controllers (for more granular control)
    left_hip_controller:
      type: position_controllers/JointPositionController
    right_hip_controller:
      type: position_controllers/JointPositionController
    left_knee_controller:
      type: position_controllers/JointPositionController
    right_knee_controller:
      type: position_controllers/JointPositionController
    # Add controllers for all joints as needed

# Joint group controller configuration
joint_group_position_controller:
  ros__parameters:
    joints:
      - hip_joint
      - knee_joint
      - ankle_joint
      # Add all joints that should be controlled as a group

# Individual controller configurations
left_hip_controller:
  ros__parameters:
    joint: left_hip_joint
    interface_name: position

right_hip_controller:
  ros__parameters:
    joint: right_hip_joint
    interface_name: position
```

## Launch File Configuration

Create a launch file to start Gazebo with the robot model:

```python
# launch/gazebo_simulation.launch.py
import os
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription, DeclareLaunchArgument
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():
    # Declare launch arguments
    use_sim_time = LaunchConfiguration('use_sim_time', default='true')
    robot_description_path = LaunchConfiguration(
        'robot_description_path',
        default=os.path.join(
            get_package_share_directory('my_robot_description'),
            'urdf',
            'humanoid_robot.urdf.xacro'
        )
    )

    # Get URDF via xacro
    robot_description_config = Command([
        'xacro', ' ', robot_description_path, ' ',
        'use_sim:=true'
    ])

    # Robot State Publisher node
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        name='robot_state_publisher',
        output='screen',
        parameters=[{
            'use_sim_time': use_sim_time,
            'robot_description': robot_description_config
        }]
    )

    # Gazebo launch
    gazebo = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            get_package_share_directory('gazebo_ros'),
            '/launch',
            '/gazebo.launch.py'
        ]),
        launch_arguments={
            'verbose': 'false',
            'pause': 'false',
        }.items()
    )

    # Spawn robot in Gazebo
    spawn_entity = Node(
        package='gazebo_ros',
        executable='spawn_entity.py',
        arguments=[
            '-topic', 'robot_description',
            '-entity', 'humanoid_robot',
            '-x', '0.0',
            '-y', '0.0',
            '-z', '1.0'
        ],
        output='screen'
    )

    # Load controllers
    load_joint_state_broadcaster = ExecuteProcess(
        cmd=['ros2', 'control', 'load_controller', '--set-state', 'start',
             'joint_state_broadcaster'],
        output='screen'
    )

    load_joint_trajectory_controller = ExecuteProcess(
        cmd=['ros2', 'control', 'load_controller', '--set-state', 'start',
             'joint_group_position_controller'],
        output='screen'
    )

    return LaunchDescription([
        DeclareLaunchArgument(
            'use_sim_time',
            default_value='true',
            description='Use simulation (Gazebo) clock if true'
        ),
        DeclareLaunchArgument(
            'robot_description_path',
            default_value=os.path.join(
                get_package_share_directory('my_robot_description'),
                'urdf',
                'humanoid_robot.urdf.xacro'
            ),
            description='Absolute path to robot urdf file'
        ),
        robot_state_publisher,
        gazebo,
        spawn_entity,
        RegisterEventHandler(
            OnProcessExit(
                target_action=spawn_entity,
                on_exit=[load_joint_state_broadcaster],
            )
        ),
        RegisterEventHandler(
            OnProcessExit(
                target_action=load_joint_state_broadcaster,
                on_exit=[load_joint_trajectory_controller],
            )
        ),
    ])
```

## Sensor Integration

### IMU Sensor Configuration

Add IMU sensor to your robot model:

```xml
<!-- IMU sensor in URDF -->
<gazebo reference="imu_link">
  <sensor name="imu_sensor" type="imu">
    <always_on>true</always_on>
    <update_rate>100</update_rate>
    <imu>
      <angular_velocity>
        <x>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>2e-4</stddev>
          </noise>
        </x>
        <y>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>2e-4</stddev>
          </noise>
        </y>
        <z>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>2e-4</stddev>
          </noise>
        </z>
      </angular_velocity>
      <linear_acceleration>
        <x>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>1.7e-2</stddev>
          </noise>
        </x>
        <y>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>1.7e-2</stddev>
          </noise>
        </y>
        <z>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>1.7e-2</stddev>
          </noise>
        </z>
      </linear_acceleration>
    </imu>
  </sensor>
</gazebo>
```

### LiDAR Sensor Configuration

Add 3D LiDAR sensor:

```xml
<!-- LiDAR sensor in URDF -->
<gazebo reference="lidar_link">
  <sensor name="lidar_sensor" type="ray">
    <always_on>true</always_on>
    <visualize>true</visualize>
    <update_rate>10</update_rate>
    <ray>
      <scan>
        <horizontal>
          <samples>720</samples>
          <resolution>1</resolution>
          <min_angle>-3.14159</min_angle>
          <max_angle>3.14159</max_angle>
        </horizontal>
        <vertical>
          <samples>16</samples>
          <resolution>1</resolution>
          <min_angle>-0.2618</min_angle>
          <max_angle>0.2618</max_angle>
        </vertical>
      </scan>
      <range>
        <min>0.1</min>
        <max>30.0</max>
        <resolution>0.01</resolution>
      </range>
    </ray>
    <plugin name="lidar_controller" filename="libgazebo_ros_ray_sensor.so">
      <ros>
        <namespace>/laser</namespace>
        <remapping>~/out:=scan</remapping>
      </ros>
      <output_type>sensor_msgs/LaserScan</output_type>
      <frame_name>lidar_link</frame_name>
    </plugin>
  </sensor>
</gazebo>
```

## Control System Integration

### Basic Control Node

Create a basic control node to interface with the simulated robot:

```python
#!/usr/bin/env python3
# control_node.py

import rclpy
from rclpy.node import Node
from std_msgs.msg import Float64MultiArray
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Twist
import numpy as np

class HumanoidController(Node):
    def __init__(self):
        super().__init__('humanoid_controller')

        # Declare parameters
        self.declare_parameter('control_frequency', 100)
        self.declare_parameter('robot_prefix', 'humanoid_robot')

        # Get parameters
        self.control_frequency = self.get_parameter('control_frequency').value
        self.robot_prefix = self.get_parameter('robot_prefix').value

        # Publishers for joint commands
        self.joint_cmd_pub = self.create_publisher(
            Float64MultiArray,
            f'/{self.robot_prefix}/joint_group_position_controller/commands',
            10
        )

        # Subscribers for sensor data
        self.joint_state_sub = self.create_subscription(
            JointState,
            f'/{self.robot_prefix}/joint_states',
            self.joint_state_callback,
            10
        )

        # Timer for control loop
        self.control_timer = self.create_timer(
            1.0 / self.control_frequency,
            self.control_loop
        )

        # Robot state
        self.joint_states = None
        self.target_positions = [0.0] * 12  # Default to 12 joints

        self.get_logger().info('Humanoid Controller initialized')

    def joint_state_callback(self, msg):
        """Update joint state from simulation."""
        self.joint_states = msg

    def control_loop(self):
        """Main control loop."""
        if self.joint_states is not None:
            # Generate control commands based on current state
            cmd_msg = Float64MultiArray()
            cmd_msg.data = self.target_positions  # Simple position control
            self.joint_cmd_pub.publish(cmd_msg)

    def set_target_positions(self, positions):
        """Set target joint positions."""
        self.target_positions = positions

def main(args=None):
    rclpy.init(args=args)
    controller = HumanoidController()

    # Example: Move to calibration position
    calibration_pos = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    controller.set_target_positions(calibration_pos)

    try:
        rclpy.spin(controller)
    except KeyboardInterrupt:
        controller.get_logger().info('Controller stopped by user')
    finally:
        controller.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Physics Configuration

### World File Configuration

Create a Gazebo world file with appropriate physics settings:

```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="humanoid_world">
    <!-- Physics engine configuration -->
    <physics type="ode">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1.0</real_time_factor>
      <real_time_update_rate>1000</real_time_update_rate>
      <gravity>0 0 -9.8</gravity>
      <ode>
        <solver>
          <type>quick</type>
          <iters>10</iters>
          <sor>1.3</sor>
        </solver>
        <constraints>
          <cfm>0.0</cfm>
          <erp>0.2</erp>
          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
          <contact_surface_layer>0.001</contact_surface_layer>
        </constraints>
      </ode>
    </physics>

    <!-- Ground plane -->
    <include>
      <uri>model://ground_plane</uri>
    </include>

    <!-- Lighting -->
    <include>
      <uri>model://sun</uri>
    </include>

    <!-- Your robot model will be spawned here -->
  </world>
</sdf>
```

## Validation and Testing

### Simulation Validation Node

Create a validation node to assess simulation quality:

```python
#!/usr/bin/env python3
# validation_node.py

import rclpy
from rclpy.node import Node
from gazebo_msgs.srv import GetModelState
from sensor_msgs.msg import JointState, Imu
from std_msgs.msg import Float64MultiArray
import numpy as np
import time

class SimulationValidator(Node):
    def __init__(self):
        super().__init__('simulation_validator')

        # Declare parameters
        self.declare_parameter('validation_frequency', 10.0)
        self.declare_parameter('validation_threshold', 0.9)

        # Get parameters
        self.validation_frequency = self.get_parameter('validation_frequency').value
        self.validation_threshold = self.get_parameter('validation_threshold').value

        # Gazebo services
        self.get_state_client = self.create_client(
            GetModelState,
            '/gazebo/get_model_state'
        )

        # Subscribers
        self.joint_state_sub = self.create_subscription(
            JointState,
            '/joint_states',
            self.joint_state_callback,
            10
        )

        self.imu_sub = self.create_subscription(
            Imu,
            '/imu/data',
            self.imu_callback,
            10
        )

        # Publishers
        self.validation_pub = self.create_publisher(
            Float64MultiArray,
            '/simulation_validation',
            10
        )

        # Timers
        self.validation_timer = self.create_timer(
            1.0 / self.validation_frequency,
            self.validation_callback
        )

        # State tracking
        self.joint_states = None
        self.imu_data = None
        self.last_validation_time = time.time()

        self.get_logger().info('Simulation Validator initialized')

    def joint_state_callback(self, msg):
        self.joint_states = msg

    def imu_callback(self, msg):
        self.imu_data = msg

    def validation_callback(self):
        """Perform validation checks."""
        if self.joint_states is None or self.imu_data is None:
            return

        # Calculate validation metrics
        metrics = self.calculate_validation_metrics()

        # Publish results
        result_msg = Float64MultiArray()
        result_msg.data = [
            metrics['stability_score'],
            metrics['kinematic_consistency'],
            metrics['sensor_accuracy'],
            metrics['overall_score']
        ]
        self.validation_pub.publish(result_msg)

        # Log status periodically
        current_time = time.time()
        if current_time - self.last_validation_time > 5.0:
            self.get_logger().info(
                f'Validation - Stability: {metrics["stability_score"]:.3f}, '
                f'Kinematic: {metrics["kinematic_consistency"]:.3f}, '
                f'Overall: {metrics["overall_score"]:.3f}'
            )
            self.last_validation_time = current_time

    def calculate_validation_metrics(self):
        """Calculate various validation metrics."""
        metrics = {}

        # Stability score based on joint positions
        if self.joint_states:
            # Check for extreme joint positions
            extreme_count = 0
            for pos in self.joint_states.position:
                if abs(pos) > 3.14:  # More than 180 degrees
                    extreme_count += 1

            metrics['stability_score'] = max(0.0, 1.0 - (extreme_count / len(self.joint_states.position)))
        else:
            metrics['stability_score'] = 1.0

        # Kinematic consistency
        metrics['kinematic_consistency'] = 0.95  # Placeholder

        # Sensor accuracy (simplified)
        metrics['sensor_accuracy'] = 0.98  # Placeholder

        # Overall score
        metrics['overall_score'] = (
            metrics['stability_score'] * 0.4 +
            metrics['kinematic_consistency'] * 0.3 +
            metrics['sensor_accuracy'] * 0.3
        )

        return metrics

def main(args=None):
    rclpy.init(args=args)
    validator = SimulationValidator()

    try:
        rclpy.spin(validator)
    except KeyboardInterrupt:
        validator.get_logger().info('Validator stopped by user')
    finally:
        validator.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Troubleshooting

### Common Issues and Solutions

1. **Robot falls through the ground**: Check inertial properties and collision geometries
2. **Joint oscillation**: Adjust physics solver parameters and joint damping
3. **Control lag**: Increase control frequency or optimize communication
4. **Sensor noise**: Verify sensor configuration parameters
5. **Performance issues**: Reduce update rates or simplify models

### Performance Optimization

- Use appropriate solver types (quick vs iterative)
- Adjust step size based on required accuracy
- Optimize collision geometries (simplified for simulation)
- Use level-of-detail (LOD) for complex models
- Monitor and limit update rates

## Best Practices

1. **Modular Design**: Keep URDF, controllers, and launch files organized
2. **Parameter Configuration**: Use launch parameters for flexibility
3. **Validation**: Implement validation nodes to assess simulation quality
4. **Documentation**: Document all configuration parameters
5. **Testing**: Create automated tests for simulation behavior
6. **Version Control**: Track simulation configurations in version control

## Next Steps

After implementing this basic integration, consider:
- Advanced sensor simulation (force/torque sensors, cameras)
- Multi-robot simulation scenarios
- Physics parameter optimization
- Sim-to-real transfer validation
- Advanced control strategies implementation